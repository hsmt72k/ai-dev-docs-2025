---
title: マイクロフロントエンド/マイクロサービス
description: Micro Frontend / Microservice
icon: Shrimp
---

import { Mermaid } from "@/components/mdx/mermaid";

## モジュール化で実現する次世代システムアーキテクチャ

### 🔑 エグゼクティブサマリー

マイクロフロントエンドとマイクロサービスは、大規模なアプリケーションを小さな独立したモジュールに分割するアーキテクチャパターンです。
このアプローチにより、複数のチームが並行して開発を進めることができ、システムの柔軟性、スケーラビリティ、保守性が向上します。

本ドキュメントでは、AI システム統合における両アーキテクチャの概念、メリット、実装方法、そして生成 AI との連携方法について解説します。
また、モジュール境界の設計ガイド、開発ワークフローとの統合、および DDD（ドメイン駆動設計）との関係についても触れています。

### 本ドキュメントの想定読者と対象システム規模

- **想定読者**:
  - エンタープライズアプリケーション設計者
  - フロントエンド/バックエンドアーキテクト
  - 大規模開発チームのリーダー
  - システム統合エンジニア
  - AI システム導入を検討している技術意思決定者

- **対象システム規模**:
  - 複数チームによる開発を要する中〜大規模アプリケーション
  - 成長を見込んだスケーラブルなシステム設計が必要なプロジェクト
  - 複数の機能や業務ドメインを持つエンタープライズアプリケーション
  - 生成 AI 機能を段階的に統合していくシステム

### 🔌 マイクロサービスの基本概念

マイクロサービスとは、アプリケーションを機能ごとに分割し、独立したサービスとして実装するアーキテクチャパターンです。
各サービスは特定のビジネス機能に焦点を当て、独自のデータストアを持ち、明確に定義された API を通じて他のサービスと通信します。

#### マイクロサービスの主要特徴

マイクロサービスアーキテクチャには、以下のような特徴があります。

- **サービスの独立性**: 各サービスは独立してデプロイ・スケーリング可能
- **技術的多様性**: サービスごとに最適な技術スタックを選択可能
- **分散データ管理**: 各サービスが独自のデータストアを管理
- **障害の局所化**: 一部のサービス障害がシステム全体に影響しにくい
- **API を介した通信**: 明確に定義されたインターフェースによる連携
- **自律的なチーム編成**: 機能単位でのチーム分割が可能

#### マイクロサービスの実装パターン

マイクロサービスを実装する際の一般的なパターンには以下のようなものがあります。

1. **API ゲートウェイパターン**: クライアントリクエストの単一エントリポイントを提供
2. **サービスディスカバリ**: 動的に変化するサービスインスタンスの検出
3. **サーキットブレーカー**: 障害伝播を防ぐための保護機構
4. **CQRS (Command Query Responsibility Segregation)**: 読み取りと書き込みの分離
5. **Saga パターン**: 分散トランザクション管理
6. **イベント駆動アーキテクチャ**: 非同期メッセージングによる緩やかな結合

<Mermaid chart={`
graph TD
    A[ユーザー] --> B[API ゲートウェイ]
    B --> C[認証サービス]
    B --> D[商品サービス]
    B --> E[決済サービス]
    B --> F[配送サービス]
    B --> G[レコメンドサービス]
    C --> C1[(認証DB)]
    D --> D1[(商品DB)]
    E --> E1[(決済DB)]
    F --> F1[(配送DB)]
    G --> G1[(レコメンドDB)]
    style B fill:#87CEFA,stroke:#0047AB,color:#000
    style C fill:#90EE90,stroke:#006400,color:#000
    style D fill:#90EE90,stroke:#006400,color:#000
    style E fill:#90EE90,stroke:#006400,color:#000
    style F fill:#90EE90,stroke:#006400,color:#000
    style G fill:#90EE90,stroke:#006400,color:#000
`} />

<div className="text-slate-400">
*図1: 典型的なマイクロサービスアーキテクチャの構成例*
</div>

### 🖥️ マイクロフロントエンドの基本概念

マイクロフロントエンドは、マイクロサービスの概念をフロントエンド開発に適用したアプローチです。
大規模なフロントエンドアプリケーションを、独立して開発・デプロイ可能な小さなアプリケーションに分割します。

#### マイクロフロントエンドの主要特徴

マイクロフロントエンドには以下のような特徴があります。

- **独立したビルド・デプロイ**: 各マイクロフロントエンドを独自のサイクルで管理
- **チーム自律性**: 機能領域ごとにチームを編成し並行開発が可能
- **技術スタックの多様性**: 領域に適した技術を選択可能
- **段階的な移行**: モノリスからの漸進的な移行をサポート
- **ビジネス領域に沿った分割**: ドメイン駆動設計の考え方との親和性
- **独立した進化**: 部分的な更新や改善が容易

#### マイクロフロントエンドの実装アプローチ

マイクロフロントエンドの実装には複数のアプローチがあります。

1. **ビルド時統合**: npm パッケージとしての共有
2. **サーバーサイド統合**: サーバー側でのコンポジション（SSI など）
3. **ランタイム統合**:
   - iframe による分離
   - Web Components によるカプセル化
   - JavaScript によるランタイム統合（Module Federation など）
4. **エッジサイド統合**: CDN やエッジワーカーでのコンテンツ結合

<Mermaid chart={`
graph TD
    A[ユーザー] --> B[シェルアプリケーション]
    B --> C[チームA: 商品一覧 MFE]
    B --> D[チームB: 商品詳細 MFE]
    B --> E[チームC: カート MFE]
    B --> F[チームD: 決済 MFE]
    C --> G[商品サービス API]
    D --> G
    E --> H[カートサービス API]
    F --> I[決済サービス API]
    style B fill:#87CEFA,stroke:#0047AB,color:#000
    style C fill:#FFD700,stroke:#B8860B,color:#000
    style D fill:#FFD700,stroke:#B8860B,color:#000
    style E fill:#FFD700,stroke:#B8860B,color:#000
    style F fill:#FFD700,stroke:#B8860B,color:#000
    style G fill:#FF6347,stroke:#8B0000,color:#000
    style H fill:#FF6347,stroke:#8B0000,color:#000
    style I fill:#FF6347,stroke:#8B0000,color:#000
`} />

<div className="text-slate-400">
*図2: マイクロフロントエンド構成の概念図*
</div>

<Callout type="info" title="シェルアプリケーションについて">
シェルアプリケーションとは、マイクロフロントエンドアーキテクチャにおいて、複数のマイクロフロントエンドを統合し、
まとめ上げる「コンテナ」または「ホスト」の役割を果たすアプリケーションです。これは全体を束ねる「殻（シェル）」として機能します。

シェルアプリケーションの主な役割は以下のとおりです。

1. 複数のマイクロフロントエンドをひとつのアプリケーションとして統合する
2. 共通のナビゲーション、ヘッダー、フッターなどを提供する
3. マイクロフロントエンド間のルーティングを管理する
4. 認証や権限などの共通機能を提供する
5. マイクロフロントエンド間の通信をサポートする

マイクロフロントエンド構成の概念図をより具体的にイメージしていただくために、例えば、EC サイトの場合を考えてみましょう。

- シェルアプリケーション：サイト全体のフレームワーク（ヘッダー、フッター、メインナビゲーション）
- 商品一覧 MFE：チームAが開発・管理する商品カタログ部分
- 商品詳細 MFE：チームBが開発・管理する商品詳細ページ
- カート MFE：チームCが担当するショッピングカート機能
- 決済 MFE：チームDが担当する決済プロセス

ユーザーからは一つの統合されたウェブサイトとして見えますが、裏側では各チームが担当する機能を独立して開発・デプロイできる構造になっています。
この構成の利点は、各チームが他のチームに依存せず、自律的に開発を進められることです。
例えば、決済チームは決済フローを変更する際に、商品カタログチームの承認を得る必要がありません。
</Callout>

### 🔧 モジュール境界の設計ガイド

適切なモジュール境界を設計することは、マイクロサービスとマイクロフロントエンドの成功において極めて重要です。
以下に、効果的な境界設計のためのガイドラインを示します。

#### ドメイン駆動設計の活用

DDD（ドメイン駆動設計）の原則を活用することで、ビジネス要件に沿った自然な境界を見つけることができます。

- **境界づけられたコンテキスト**: 共通の用語と概念を持つ領域を特定
- **ユビキタス言語**: 各ドメイン内での一貫した専門用語の使用
- **コンテキストマップ**: 異なるドメイン間の関係の明確化
- **集約**: 一貫性を保つべきエンティティのグループ化

#### 適切な粒度の決定基準

サービス/フロントエンドの粒度を決定する際の考慮点です。

- **チーム構造に合わせる**: 「2ピザチーム」が管理できる規模を目安に
- **変更の頻度と理由**: 同じ理由で変更される要素をグループ化
- **スケーリング要件**: 異なるスケーリングニーズを持つ機能は分離
- **技術的多様性の必要性**: 特殊な技術要件がある場合は分離を検討
- **ビジネスクリティカリティ**: 重要度の高い機能の分離を検討

#### ドメインごとの切り分け例

一般的なシステムにおけるドメイン分割の例です。

1. **ECサイトの例**:
   - 商品カタログサービス
   - 在庫管理サービス
   - カートサービス
   - 注文管理サービス
   - 決済サービス
   - ユーザープロファイルサービス
   - レコメンデーションサービス

2. **金融システムの例**:
   - 口座管理サービス
   - 取引サービス
   - 認証・認可サービス
   - 通知サービス
   - レポーティングサービス
   - コンプライアンスサービス

3. **SaaSプラットフォームの例**:
   - ユーザー管理サービス
   - 課金サービス
   - テナント管理サービス
   - データ処理サービス
   - アナリティクスサービス
   - 通知サービス

#### インターフェース設計のベストプラクティス

モジュール間のインターフェースを設計する際のベストプラクティスです。

- **契約駆動開発**: インターフェース仕様の明確な定義と合意
- **バージョニング**: 互換性を保ちながらの進化をサポート
- **耐障害設計**: 依存サービスの障害に備えた設計
- **非同期通信の活用**: 緩やかな結合のためのイベント駆動アプローチ
- **統一された認証・認可**: 一貫性のあるセキュリティモデル

### 🛠️ 開発ワークフロー（CI/CD）との統合

マイクロサービス/マイクロフロントエンドのアーキテクチャは、
効率的な CI/CD（継続的インテグレーション/継続的デリバリー）パイプラインとの統合により、その価値を最大化できます。

#### 自動化パイプラインの構築

分散アーキテクチャに適した自動化パイプラインの要素です。

- **モノレポ vs マルチレポ**: リポジトリ戦略の選択
- **独立したビルド/デプロイ**: 各サービス/フロントエンドの独立したパイプライン
- **依存関係の管理**: 共有ライブラリやコンポーネントのバージョン管理
- **マイクロフロントエンド統合テスト**: コンポジションの自動検証
- **カナリアリリース**: 段階的なデプロイによるリスク低減

#### 環境管理とコンテナ化

開発・テスト・本番環境の効率的な管理手法です。

- **コンテナオーケストレーション**: Kubernetes による一貫した環境
- **サービスメッシュ**: トラフィック管理と可観測性の強化
- **ローカル開発環境**: マイクロサービスのローカル実行支援ツール
- **環境間の一貫性**: 「Infrastructure as Code」アプローチ
- **構成管理**: 環境ごとの設定値の管理

#### 監視と可観測性

分散システムの健全性を確保するための監視体制です。

- **分散トレーシング**: リクエストの流れの可視化
- **集中ログ管理**: 全サービスのログの統合分析
- **メトリクス収集**: パフォーマンスと健全性の指標監視
- **アラート設定**: 異常検知と通知の自動化
- **サービスレベル目標（SLO）**: サービス品質の定量的な目標設定

### 🤖 生成 AI との統合ポイント

大規模アプリケーションにおける生成 AI の統合は、マイクロサービスとマイクロフロントエンドのアーキテクチャを活用することで効果的に実現できます。

#### マイクロサービスでの AI 統合パターン

生成 AI をマイクロサービスとして統合する主なアプローチを紹介します。

1. **AI 特化サービス**:
   - レコメンデーションエンジン
   - 自然言語処理サービス
   - 画像・音声認識サービス
   - コンテンツ生成サービス

2. **AI オーケストレーション層**:
   - プロンプト管理
   - モデル選択ロジック
   - コンテキスト管理
   - フォールバック処理

3. **データアクセス最適化**:
   - ベクトルデータベース統合
   - エンベディングキャッシュ
   - RAG (Retrieval-Augmented Generation) 処理
   - セマンティック検索サービス

#### マイクロフロントエンドでの AI UI パターン

生成 AI 機能をユーザーインターフェースに統合するパターンです。

1. **チャットインターフェース MFE**:
   - 会話履歴管理
   - ストリーミング表示
   - プロンプトテンプレート

2. **AI アシスタント MFE**:
   - コンテキスト対応サポート
   - タスク特化インターフェース
   - フィードバックメカニズム

3. **コンテンツ生成 MFE**:
   - テキストエディタ拡張
   - 画像生成インターフェース
   - 対話型コンテンツ作成

4. **検索・レコメンデーション MFE**:
   - セマンティック検索 UI
   - パーソナライズド推奨
   - 探索的検索インターフェース

### 🧠 DDD（ドメイン駆動設計）との関係性

マイクロサービス/マイクロフロントエンドアーキテクチャと DDD（ドメイン駆動設計）の間には強い親和性があります。
DDD の概念と原則は、効果的なモジュール分割の基盤となります。

#### DDD の主要概念とマイクロサービスの対応

DDD の中核概念とマイクロサービスアーキテクチャの関連性です。

- **境界づけられたコンテキスト**:
  - マイクロサービスの自然な境界として機能
  - ドメイン固有言語（DSL）の適用範囲の定義
  - チーム編成の単位としての活用

- **ドメインモデル**:
  - サービス固有のビジネスロジックのカプセル化
  - 集約ルートを中心としたデータ整合性管理
  - ドメインイベントによるサービス間連携

- **戦略的設計**:
  - コンテキストマップを活用したサービス関係の可視化
  - 上流・下流関係に基づくインターフェース設計
  - アンチコラプションレイヤーによる外部システム統合

#### マイクロフロントエンドへの DDD 原則適用

DDD の考え方をフロントエンド設計に適用する方法です。

- **ユーザー志向の境界**:
  - ユーザージャーニーに基づく機能分割
  - ユースケースを中心とした画面設計
  - ドメインに沿ったコンポーネント構成

- **プレゼンテーションモデル**:
  - ビューモデルによるドメインモデルの変換
  - UI 状態管理の分離と独立性確保
  - コマンド/クエリの明示的な分離

#### イベント駆動アーキテクチャとの統合

DDD とイベント駆動アーキテクチャの組み合わせによる疎結合設計です。

- **ドメインイベント**:
  - ビジネス上の重要な状態変化の通知
  - サービス間の非同期通信メカニズム
  - イベントソーシングによる状態管理
  - CQRS パターンの実装基盤

- **イベントストーミング**:
  - チーム横断的なドメインモデリング手法
  - イベントフローに基づくサービス境界の特定
  - ビジネスプロセスの可視化と共通理解の形成

<div className="max-w-98">
<Mermaid chart={`
graph TD
    A[ビジネスドメイン] --> B[戦略的DDD]
    B --> C[境界づけられたコンテキスト]
    C --> D[マイクロサービス境界]
    C --> E[マイクロフロントエンド境界]
    D --> F[サービスAPI設計]
    E --> G[UI構成設計]
    F --> H[GraphQL Federation/BFF]
    G --> I[Module Federation/Web Components]
    H --> J[CI/CD パイプライン]
    I --> J
    J --> K[デプロイ自動化]
    K --> L[本番環境]
    L --> M[モニタリング/可観測性]
    style A fill:#87CEFA,stroke:#0047AB,color:#000
    style B fill:#90EE90,stroke:#006400,color:#000
    style C fill:#90EE90,stroke:#006400,color:#000
    style D fill:#FFD700,stroke:#B8860B,color:#000
    style E fill:#FFD700,stroke:#B8860B,color:#000
    style H fill:#FF6347,stroke:#8B0000,color:#000
    style I fill:#FF6347,stroke:#8B0000,color:#000
    style J fill:#FF6347,stroke:#8B0000,color:#000
`} />
</div>

<div className="text-slate-400">
*図3: ドメイン駆動設計を基盤としたマイクロサービス/マイクロフロントエンド実装フロー*
</div>

### 🚀 先進的な実装アプローチ

最新の技術トレンドを活用したマイクロサービス/マイクロフロントエンドの実装アプローチを紹介します。

#### MFE + Serverless + Edge AI による構成例

クラウドネイティブかつエッジコンピューティングを活用した最新アプローチです。

- **Vercel/Cloudflare との統合**:
  - Vercel Edge Functions を活用した SSR マイクロフロントエンド
  - Cloudflare Workers による API プロキシとエッジ処理
  - KV ストレージを活用した分散キャッシュ
  - Edge AI 推論エンジンによるレイテンシ削減
  - 地理的に分散したエッジでのパーソナライゼーション

- **実装パターン**:
  - Next.js App Router による MFE 間ナビゲーション
  - Edge Config による動的構成管理
  - Cloudflare AI Worker による軽量推論
  - WebAssembly を活用した高性能エッジ処理
  - Streaming SSR によるインタラクティブコンテンツ配信

<Mermaid chart={`
graph TD
    A[ユーザー] --> B[CDN/Edge Network]
    B --> C[Shell MFE]
    C --> D[Team A MFE]
    C --> E[Team B MFE]
    C --> F[Team C MFE]
    D --> G[Edge Function A]
    E --> H[Edge Function B]
    F --> I[Edge Function C]
    G --> J[Serverless API A]
    H --> K[Serverless API B]
    I --> L[Serverless API C]
    G --> M[Edge AI 推論]
    H --> M
    J --> N[永続化ストア]
    K --> N
    L --> N
    J --> O[AI モデルサービス]
    K --> O
    L --> O
    style B fill:#87CEFA,stroke:#0047AB,color:#000
    style C fill:#FFD700,stroke:#B8860B,color:#000
    style D fill:#FFD700,stroke:#B8860B,color:#000
    style E fill:#FFD700,stroke:#B8860B,color:#000
    style F fill:#FFD700,stroke:#B8860B,color:#000
    style G fill:#90EE90,stroke:#006400,color:#000
    style H fill:#90EE90,stroke:#006400,color:#000
    style I fill:#90EE90,stroke:#006400,color:#000
    style M fill:#FF6347,stroke:#8B0000,color:#000
    style O fill:#FF6347,stroke:#8B0000,color:#000
`} />

<div className="text-slate-400">
*図4: MFE + Serverless + Edge AI による最新アーキテクチャ構成例*
</div>

#### GraphQL Federation と BFF パターン

マイクロサービスとフロントエンドの連携を効率化する統合レイヤーです。

- **GraphQL Federation**:
  - 複数のマイクロサービスをまたぐスキーマ統合
  - 分散クエリ実行と最適化
  - 型安全な API レイヤー
  - スキーマ進化の管理
  - パーミッション制御

- **BFF (Backends for Frontends)**:
  - クライアント特化のバックエンドアダプター
  - デバイス/ユースケース別の最適化
  - マイクロサービス集約と変換
  - 認証・認可の簡素化
  - 複数リクエストの統合によるネットワーク効率化

#### サーバーレスアーキテクチャとの統合

マイクロサービスのサーバーレス実装による運用効率の向上です。

- **AWS Lambda / Azure Functions / Cloud Run**:
  - イベント駆動型マイクロサービス
  - 自動スケーリングによる効率的なリソース利用
  - ゼロインフラストラクチャ管理
  - 従量課金モデルによるコスト最適化
  - コールドスタート対策とウォームスタート戦略

### 📊 アーキテクチャ採用の判断基準

マイクロサービス/マイクロフロントエンドアーキテクチャを採用すべきか判断するための指標です。

#### 採用を検討すべき状況

以下の条件に当てはまる場合、マイクロサービス/マイクロフロントエンドの採用を検討すべきです。

- 複数チームが並行して開発する必要がある
- 異なる更新サイクルを持つ機能群が存在する
- スケーラビリティ要件が機能によって異なる
- 段階的なレガシーシステム刷新が必要
- 異なるビジネスドメイン間の明確な境界がある
- 技術スタックの多様性が求められる
- AI 機能を段階的に追加していく計画がある

#### 考慮すべき課題とトレードオフ

分散アーキテクチャの採用には以下の課題もあります。

- 分散システムの複雑性増加
- オペレーションオーバーヘッドの増加
- チーム間調整コストの上昇
- 一貫性のあるユーザー体験維持の難しさ
- 開発・テスト環境の複雑化
- デバッグ・トラブルシューティングの難易度上昇
- クロスカッティング・コンサーンの扱い

### 🧪 実装パターンと実践例

#### マイクロサービス実装技術

マイクロサービスの実装に活用される主な技術です。

- **コンテナオーケストレーション**: Docker、Kubernetes
- **API ゲートウェイ**: Kong、AWS API Gateway、Azure API Management
- **サービスメッシュ**: Istio、Linkerd、Consul
- **メッセージングシステム**: Kafka、RabbitMQ、NATS
- **分散トレーシング**: Jaeger、Zipkin、OpenTelemetry
- **API 定義**: OpenAPI、gRPC、GraphQL
- **認証・認可**: OAuth2、OIDC、Keycloak

#### マイクロフロントエンド実装技術

マイクロフロントエンドの実装に活用される主な技術です。

- **Module Federation**: Webpack 5、Vite
- **Web Components**: Custom Elements、Shadow DOM
- **統合レイヤー**: single-spa、Luigi、Piral
- **エッジサイド統合**: Cloudflare Workers、Vercel Edge Functions
- **ビルドツール**: Nx、Turborepo、Lerna
- **スタイル分離**: CSS Modules、CSS-in-JS、Shadow DOM
- **状態共有**: Redux、Zustand、XState

### 📝 まとめ

マイクロサービスとマイクロフロントエンドは、大規模アプリケーション開発における重要なアーキテクチャパターンです。
独立した開発・デプロイサイクル、チームの自律性、技術的多様性などの利点がある一方で、分散システムの複雑性や運用コストの増加といった課題も存在します。

生成 AI システムの統合においては、AI 特化サービスや専用 UI コンポーネントとして実装することで、柔軟性と保守性を高めることができます。
効果的な実装には、ドメイン駆動設計の原則を取り入れたモジュール境界の設計、効率的な CI/CD パイプラインの構築、
そして先進的な技術（Serverless、Edge Computing、GraphQL Federation など）の適切な活用が重要です。

最終的に、プロジェクトの規模、チーム構成、将来的な拡張性、および技術的な要件を総合的に考慮し、
適切なタイミングでこれらのアーキテクチャを採用することが成功への鍵となります。
マイクロサービス/マイクロフロントエンドは万能のソリューションではなく、ビジネス価値を最大化するための手段として戦略的に活用すべきです。

### 📚 用語解説

| 用語 | 説明 |
|------|------|
| マイクロサービス | アプリケーションを独立したサービスに分割するアーキテクチャパターン |
| マイクロフロントエンド (MFE) | フロントエンドアプリケーションを独立したモジュールに分割するアプローチ |
| API ゲートウェイ | クライアントリクエストの単一エントリポイントとなるサービス |
| サービスメッシュ | マイクロサービス間の通信を管理するインフラストラクチャレイヤー |
| Module Federation | 複数の JavaScript アプリケーションを動的に統合する仕組み |
| コンテナオーケストレーション | コンテナ化されたアプリケーションのデプロイと運用を自動化する技術 |
| CQRS | コマンド（書き込み）とクエリ（読み取り）の責務を分離するパターン |
| サーキットブレーカー | 障害の連鎖を防ぐためのフォールトトレランスパターン |
| Saga パターン | 分散トランザクションを管理するための設計パターン |
| RAG | 検索拡張生成。外部知識を LLM の生成プロセスに統合する手法 |
| DDD | ドメイン駆動設計。ビジネスドメインを中心としたソフトウェア設計手法 |
| 境界づけられたコンテキスト | DDD における一貫した意味を持つドメインモデルの範囲 |
| BFF | Backends for Frontends。特定のフロントエンド向けに最適化されたバックエンド |
| GraphQL Federation | 複数のGraphQLサービスを単一のスキーマに統合する仕組み |
| CI/CD | 継続的インテグレーション/継続的デリバリー。自動化されたビルド・テスト・デプロイプロセス |
| イベントソーシング | システムの状態変化をイベントシーケンスとして記録・再生する手法 |
| Serverless | サーバー管理不要でコードを実行するクラウドコンピューティングモデル |
| Edge Computing | エンドユーザーの近くでデータ処理を行うコンピューティングパラダイム |
