---
title: 障害耐性設計
description: Design for Fault Tolerance
icon: ShieldCheck
---

## AI サービス停止時のグレースフルデグラデーション - 障害耐性設計ガイド

### 想定読者と前提条件

本ドキュメントは以下の読者を対象としています：
- AI サービスを組み込んだシステムの設計者・開発者
- SRE (Site Reliability Engineering) チームのメンバー
- プロダクトマネージャーやテクニカルリード

対象とするシステム規模：
- 複数のマイクロサービスで構成された中〜大規模システム
- AI コンポーネントが重要な役割を果たすが、システム全体の一部として組み込まれているアーキテクチャ
- 高可用性（99.9%以上）が求められるビジネスクリティカルなシステム

前提知識：
- マイクロサービスアーキテクチャの基本概念
- 分散システムにおける障害モード
- 基本的な AI サービス連携の知識

### 🔑 エグゼクティブサマリー

AI システムが停止した場合でもサービス全体が完全に機能停止することなく、段階的に機能を低下させながら重要な機能を維持できるよう設計することが重要です。
この「グレースフルデグラデーション」と呼ばれる手法により、ユーザー体験を可能な限り維持しながら、システムの回復力を高めることができます。
本ドキュメントでは、AI サービスにおける障害耐性設計の原則とグレースフルデグラデーションの実装方法について説明します。

#### フォールバック戦略サマリー

| フォールバック戦略 | 特徴 | 適用タイミング | 主なリスク |
|-------------------|------|--------------|-----------|
| ルールベース代替 | 精度は低いが即応性が高い | フェーズ 3 以降 | バイアスの可能性、複雑なケースへの対応不足 |
| キャッシュ利用 | 高速で既知の入力に対応 | フェーズ 1〜2 | データ鮮度の低下、キャッシュミス |
| 事前計算結果 | AI の一部タスクをバッチで計算 | フェーズ 2〜3 | 静的化による柔軟性の欠如、計算リソース消費 |
| 軽量モデル代替 | 本番モデルより単純化したモデル | フェーズ 2 | 精度低下、機能制限 |
| 手動プロセス | 人的リソースによる代替 | フェーズ 4 | スケーラビリティの制限、コスト増加 |

### 障害耐性設計の基本概念

障害耐性設計とは、システム内の一部コンポーネントが故障や停止した場合でも、システム全体が完全に機能停止することなく動作を続けるための設計手法です。
特に AI サービスのような複雑なシステムでは、以下の理由から障害耐性が重要となります。

- システムの信頼性向上
- サービス継続性の確保
- ユーザー体験の保持
- ビジネス継続性の確保
- 復旧時間の短縮

#### AI サービスにおける障害パターン

AI システムに特有の障害パターンを理解することで、より効果的な対策を講じることができます。主な障害パターンには以下が含まれます。

- **レスポンス遅延**: AI モデル処理時間が異常に長くなる
- **予測精度劣化**: AI モデルの出力品質が低下する
- **キャパシティ超過**: トラフィック増加によりモデルサーバーの処理能力を超える
- **モデル未学習状態**: 新しい条件やエッジケースに対応できない
- **依存サービス障害**: AI が依存する外部データソースやサービスの障害
- **バージョン互換性問題**: モデルアップデート時の API やスキーマの非互換性

各障害パターンに対して、適切なグレースフルデグラデーション戦略を選択することが重要です。

### グレースフルデグラデーションとは

グレースフルデグラデーション（優雅な劣化）とは、システムの一部が故障した際に、全機能の停止ではなく、
機能を段階的に制限しながらもコアとなる機能を維持することで、ユーザーに対して最低限のサービスを提供し続ける手法です。

#### グレースフルデグラデーションの特徴

- 完全な機能停止を避け、段階的に機能を低下させる
- 重要度に基づいて機能の優先順位を設定する
- ユーザーに適切な通知を行う
- システム復旧後に完全な機能を自動的に回復する

### グレースフルデグラデーションの段階的アプローチ

AI サービス障害時のグレースフルデグラデーションは、障害の程度に応じて段階的に実施することが効果的です。
以下に、フェーズ別のアプローチを説明します。

import { Mermaid } from "@/components/mdx/mermaid";

<Mermaid chart={`
graph TD
    A[フェーズ0: 通常稼働] -->|レスポンス遅延検出| B[フェーズ1: 性能劣化]
    B -->|一部機能停止| C[フェーズ2: 限定機能]
    C -->|API完全停止| D[フェーズ3: AI API停止]
    D -->|長期化| E[フェーズ4: 完全代替・保守モード]

    D -->|復旧| A
    C -->|復旧| A
    B -->|復旧| A
    E -->|復旧| A

    classDef normal fill:#0a7d33,stroke:#044a1e,color:white,stroke-width:2px;
    classDef degraded fill:#ca8a04,stroke:#854d0e,color:white,stroke-width:2px;
    classDef limited fill:#ea580c,stroke:#9a3412,color:white,stroke-width:2px;
    classDef stopped fill:#dc2626,stroke:#991b1b,color:white,stroke-width:2px;
    classDef maintenance fill:#4b5563,stroke:#1f2937,color:white,stroke-width:2px;

    class A normal;
    class B degraded;
    class C limited;
    class D stopped;
    class E maintenance;
`} />

#### フェーズ 0: 通常稼働（正常状態）

全 AI 機能が安定稼働しており、ユーザーへの応答は高速かつ正確です。

- モデルはクラウド推論環境上で完全稼働
- フル機能でパーソナライズされた体験を提供
- 通常のレスポンスタイムとスループットを維持
- すべての AI 高度機能（予測、レコメンデーション、自然言語理解など）が利用可能

#### フェーズ 1: 性能劣化（レスポンス遅延）

AI サービスは動作しているが、応答時間が長くなっている状態です。

- タイムアウト時間の一時的延長
- 非同期処理への切り替え
- ユーザーへの待機通知表示
- バックグラウンド処理への移行

#### フェーズ 2: 限定機能（部分的障害）

AI サービスの一部の機能のみが利用可能な状態です。

- 重要度の低い AI 機能の一時的無効化
- 処理の優先順位付けと制限
- キャッシュデータの積極的活用
- 単純化されたモデルへの切り替え

#### フェーズ 3: AI API 停止（完全障害）

AI サービス API が完全に利用できない状態です。

- 事前定義されたルールベースロジックへの切り替え
- 静的なフォールバックコンテンツの提供
- UX 対策:
  - チャット UI を FAQ 検索モードに切り替え
  - 障害状況の明示と謝意の表示
  - 想定される復旧時間の通知
  - 代替機能の案内（「こちらの方法もお試しください」）

#### フェーズ 4: 完全代替・保守モード（長期障害）

AI サービスの長期停止に備えた代替システムです。

- 完全な手動プロセスへの切り替え
- 簡易 UI モードの有効化
- カスタマーサポートの強化
- ログ/トラッキング方針:
  - 代替 UI/機能への遷移率を記録
  - 障害影響度とユーザー満足度の定量評価に活用
  - 障害中のユーザー行動パターン分析によるフォールバック戦略の改善

#### フェーズ間の復旧プロセス

各フェーズから正常状態への復旧時には、以下のような対応が必要です。

- **フェーズ 1 からの復旧**:
  - 性能指標の正常値確認（レスポンスタイム、エラー率など）
  - 一時的に延長したタイムアウト設定の元に戻す
  - ログ分析による性能低下の根本原因特定

- **フェーズ 2 からの復旧**:
  - 無効化していた AI 機能の段階的再有効化
  - 各機能の健全性確認テスト実行
  - キャッシュデータから最新 AI モデル結果への段階的切替

- **フェーズ 3 からの復旧**:
  - サーキットブレーカーの半オープン状態への移行
  - 限定トラフィックでの AI サービス応答確認
  - キャッシュされていたリクエストの AI サービスへの再送信
  - ルールベースロジックから AI モデルへの段階的切替

- **フェーズ 4 からの復旧**:
  - システム全体の健全性評価
  - 手動プロセスから自動処理への慎重な移行
  - カスタマーサポート体制の通常モードへの段階的移行
  - 障害期間中に蓄積されたデータの処理計画実行

各フェーズの移行は、システムの状態監視と事前定義されたトリガー条件に基づいて自動的または手動で行います。
フェーズごとの明確な移行基準を定め、システム運用チームと開発チームで共有しておくことが重要です。

### AI サービスにおけるグレースフルデグラデーションの実装戦略

AI サービスが停止した場合のグレースフルデグラデーションを実現するための主要な戦略は以下の通りです。

<Callout type="info">
AIサービスのグレースフルデグラデーションを実現するためには、システムアーキテクチャ・サービス設計・ユーザー体験の3つの観点から戦略を構築する必要があります。
本章では、主に以下の2つの側面から実装の方針を説明します。

- フォールバックメカニズムの設計と注意点
- サービス機能の階層化と機能優先度に応じた設計
</Callout>

#### 1. フォールバックメカニズムの実装

AI コンポーネントが利用できない場合に備えて、代替の処理パスを用意します。

- **ルールベースのフォールバック**: AI モデルの代わりに、シンプルなルールベースのロジックを使用
  - **具体例**: 感情分析 AI が停止した場合、キーワードマッチングによる簡易感情分析を実行
    ```python title="AI 感情分析のフォールバック例"
    def simple_sentiment_analysis(text):
        positive_words = ["良い", "素晴らしい", "満足", "happy", "excellent"]
        negative_words = ["悪い", "不満", "残念", "disappointing", "bad"]

        positive_score = sum(1 for word in positive_words if word in text.lower())
        negative_score = sum(1 for word in negative_words if word in text.lower())

        if positive_score > negative_score:
            return "ポジティブ"
        elif negative_score > positive_score:
            return "ネガティブ"
        else:
            return "中立"
    ```
- **キャッシュされた結果の使用**: 過去の AI 処理結果をキャッシュし、同様のリクエストに対して再利用
  - **具体例**: 画像分類 AI の結果を Redis に 24 時間キャッシュし、同一または類似画像に対して再利用
- **事前計算された結果の活用**: 一般的なクエリに対する回答を事前に計算して保存
  - **具体例**: 週次バッチ処理で上位 1000 商品のレコメンデーションを事前計算し、AI 停止時に使用

#### フォールバック実装時の注意点

フォールバックメカニズムを実装する際には、以下のリスクと対策を考慮する必要があります。

- **キャッシュの鮮度問題**: 長期間キャッシュされたデータは最新状況を反映せず、ユーザー体験を損なう可能性がある
  - **対策**: キャッシュのTTL（有効期限）を適切に設定し、古すぎるデータは使用しない
- **代替アルゴリズムの精度と公平性**: シンプルなルールベースのアルゴリズムは、特定のユーザーグループに対して偏った結果を返す可能性がある
  - **対策**: フォールバックアルゴリズムも定期的に評価・調整し、バイアス軽減を図る
- **ユーザー混乱のリスク**: 通常モードとフォールバックモードでの大きな挙動の違いがユーザーを混乱させる
  - **対策**: モード切替時の明確な通知と、可能な限り一貫した体験の維持
- **フォールバック切替の判断基準**: 早すぎる切替や遅すぎる切替がシステム全体のパフォーマンスに影響する
  - **対策**: 適切なヘルスチェックと複数の指標に基づく切替判断ロジックの実装

#### 2. サービスの階層化設計

サービスを複数の階層に分け、重要度に応じた設計を行います。

- **クリティカル機能**: システムの中核となる機能（常に利用可能であるべき）
- **重要機能**: ユーザー体験に重要だが、一時的な制限が許容される機能
- **付加価値機能**: なくても基本機能に影響しない拡張機能（AI による高度な分析など）

<Mermaid chart={`
graph TD
    subgraph "階層化設計"
    A[サービス全体] --> B[クリティカル機能]
    A --> C[重要機能]
    A --> D[付加価値機能]

    B --> B1[認証・認可]
    B --> B2[基本データアクセス]
    B --> B3[トランザクション処理]

    C --> C1[検索機能]
    C --> C2[ユーザー設定]

    D --> D1[AI分析]
    D --> D2[高度なレコメンデーション]
    D --> D3[予測機能]
    end

    classDef critical fill:#0b4a6e,stroke:#082f49,color:white,stroke-width:2px;
    classDef important fill:#4b5563,stroke:#1f2937,color:white,stroke-width:2px;
    classDef valueAdd fill:#6b21a8,stroke:#3b0764,color:white,stroke-width:2px;
    classDef default fill:#f8fafc,stroke:#64748b,color:#000;

    class B,B1,B2,B3 critical;
    class C,C1,C2 important;
    class D,D1,D2,D3 valueAdd;
`} />

#### 3. サーキットブレーカーパターンの採用

サービスの過負荷や連鎖的な障害を防ぐためのメカニズムを実装します。

- **障害検出**: AI サービスの応答時間や障害率をモニタリング
- **サーキットオープン**: 障害率が閾値を超えたら一時的にサービス呼び出しを停止
- **半オープン状態**: 一定時間後に限定的なトラフィックを許可して回復を確認
- **サーキットクローズ**: 正常動作が確認できたら完全に復旧

<Mermaid chart={`
graph LR
    A[通常状態] -->|障害検出| B[サーキットオープン]
    B -->|一定時間経過| C[半オープン状態]
    C -->|正常動作確認| A
    C -->|障害継続| B

    classDef normal fill:#0a7d33,stroke:#044a1e,color:white,stroke-width:2px;
    classDef open fill:#c2410c,stroke:#7c2d12,color:white,stroke-width:2px;
    classDef halfOpen fill:#a16207,stroke:#713f12,color:white,stroke-width:2px;

    class A normal;
    class B open;
    class C halfOpen;
`} />

#### 4. 非同期処理とキューイング

AI 処理を非同期化し、システム負荷を分散させます。

- **メッセージキュー**: AI 処理リクエストをキューに格納し、AI サービスの復旧後に処理
- **バックグラウンド処理**: 即時の応答が不要な処理を後回しにする仕組み
- **優先度ベースの処理**: クリティカルなリクエストを優先的に処理

<Mermaid chart={`
graph LR
    A[クライアント] -->|リクエスト| B[API Gateway]
    B -->|即時処理必要| C[同期処理]
    B -->|遅延許容| D[メッセージキュー]
    C -->|結果| A
    D --> E[ワーカー1]
    D --> F[ワーカー2]
    D --> G[ワーカー3]
    E & F & G -->|AI処理| H[AI Service]
    H -->|結果| I[結果保存]
    I --> J[通知サービス]
    J -->|処理完了通知| A

    subgraph "非同期処理パターン"
    D
    E
    F
    G
    H
    I
    J
    end

    classDef client fill:#0f766e,stroke:#0f766e,color:white,stroke-width:2px;
    classDef sync fill:#0284c7,stroke:#0284c7,color:white,stroke-width:2px;
    classDef async fill:#7c3aed,stroke:#5b21b6,color:white,stroke-width:2px;
    classDef aiservice fill:#db2777,stroke:#9d174d,color:white,stroke-width:2px;

    class A client;
    class B,C sync;
    class D,E,F,G,I,J async;
    class H aiservice;
`} />

**非同期処理の設計例:**

```js title="メッセージキューを使った非同期処理（擬似コード）"
async function handleImageAnalysisRequest(req, res) {
  const imageId = req.params.id;
  const priority = determinePriority(req);

  try {
    // AI サービスのヘルスチェック
    const aiStatus = await checkAIServiceHealth();

    if (aiStatus === 'healthy' && priority === 'high') {
      // 健全状態＆高優先度: 同期処理
      const result = await aiService.analyzeImage(imageId);
      return res.json({ status: 'complete', result });
    } else {
      // キューに追加して非同期処理
      const jobId = await messageQueue.enqueue({
        type: 'image_analysis',
        imageId,
        priority,
        timestamp: Date.now()
      });

      // クライアントにジョブIDを返す
      return res.json({
        status: 'processing',
        jobId,
        estimatedCompletionTime: calculateETA(priority, aiStatus)
      });
    }
  } catch (error) {
    // エラー時はフォールバック（キャッシュや事前計算結果）
    const fallbackResult = await getFallbackResult(imageId);
    return res.json({
      status: 'degraded',
      result: fallbackResult,
      message: 'Using cached result due to processing limitations'
    });
  }
}
```

この設計パターンにより、AI サービスの負荷を分散し、優先度に基づいて処理順序を制御できます。
また、システム状態に応じて同期/非同期処理を動的に切り替えることで、ユーザー体験を最適化します。

#### 5. 分散システム設計パターン

システム全体の耐障害性を高めるパターンを採用します。

- **ブルキャナリーデプロイメント**: 新バージョンを一部のユーザーにのみ提供して影響を限定
- **シャドウテスト**: 実際のリクエストを本番と開発環境の両方で処理し比較
- **A/B テスト**: 複数の AI モデルを同時運用し、最適なものを選択

### ユーザー体験の考慮

グレースフルデグラデーション時のユーザー体験を考慮した設計も重要です。

#### 透明性の確保

- **明確な通知**: AI 機能が低下している場合はユーザーに通知
- **代替手段の提示**: 利用可能な代替機能や回避策を提案
- **予想される復旧時間の提示**: 可能であれば、機能が完全に復旧する見込み時間を伝える

#### UI/UX の適応

- **機能の無効化表示**: 利用できない機能を明示的にグレーアウトする
- **簡易モードへの切替**: 複雑な AI 機能の代わりに基本機能のみを表示
- **プログレッシブエンハンスメント**: 基本機能から始め、利用可能なリソースに応じて機能を拡張

#### 簡易モードの設計原則

簡易モードへの切り替え時には、以下の設計原則を考慮することが重要です。

- **合理的なデフォルト値の提供**: AI が通常提供する推奨値の代わりにシステムデフォルト値を使用
- **入力フィールドの簡素化**: 高度なオプションを非表示にし、必須項目のみに絞る
- **ビジュアル要素の軽量化**: データ可視化の複雑さを減らし、テーブル形式など基本表示に切り替え
- **バッチ処理への移行**: リアルタイム処理からキューイングベースの処理に切り替え
- **ユーザー期待値の適切な管理**: 「簡易モード中」のバナー表示など、現状を明示

#### AI に依存しない UX 設計のアプローチ

AI 機能の障害時にもスムーズな UX を維持するためには、「AI の存在を意識させない自然なデフォルト UX」の設計が重要です。

- **プログレッシブ・ディスクロージャー**: AI による高度な機能は追加機能として設計し、基本機能を独立させる
  - **例**: Google 検索の自動補完が停止しても基本検索機能は正常動作
  - **例**: メールアプリの返信候補生成が停止しても、通常のメール作成機能は影響を受けない

- **マルチモーダルインターフェース**: 複数の操作方法を用意し、AI 依存の UI に問題が生じても代替手段がある設計
  - **例**: 音声アシスタントに障害が発生しても、同等の機能をタッチ操作で実行可能

- **優雅なデグラデーション**: AI 機能が連続的に低下しても UI の一貫性を維持
  - **例**: 不動産アプリの物件推薦が AI から統計ベースに切り替わっても、同じカード UI を維持
  - **例**: チャットボットが AI から FAQ 検索に切り替わっても、同じチャットインターフェースを維持

- **状態表示の最小化**: AI 機能の状態を過度に強調せず、ユーザーの本来の目的達成に焦点を当てる
  - **例**: 「AI 停止中」などの警告ではなく、「基本検索モード」「簡易表示モード」などの肯定的な表現を使用

このようなアプローチにより、AI 機能の障害時にもユーザーが混乱することなく、タスクを継続できる UX を実現できます。

### モニタリングと改善のサイクル

グレースフルデグラデーションの効果を継続的に向上させるためのプロセスを確立します。

#### 包括的なモニタリング

- **システム健全性指標**: CPU、メモリ、ネットワーク等のリソース使用状況
- **AI サービス指標**: レイテンシ、スループット、エラー率、予測精度
- **ユーザー体験指標**:
  - **行動指標**: セッション継続率、タスク完了率、ページ滞在時間
  - **満足度指標**: Net Promoter Score (NPS)、顧客満足度スコア (CSAT)
  - **比較指標**: 通常時 vs 劣化時のユーザーパスの違い
  - **フィードバック**: サポートチケット数、アプリ内フィードバックの質的分析

#### インシデント分析と改善

- **障害ポストモーテム**: 発生した障害の詳細な分析と文書化
- **改善点の特定**: 障害発生時の対応で改善できる点の洗い出し
- **設計へのフィードバック**: 分析結果を設計プロセスに反映

#### フェーズ別復旧トラッキングと分析

AI サービス障害からの復旧プロセスを継続的に改善するために、以下のようなトラッキングと分析を実施します。

- **フェーズ移行の記録**:
  - 各フェーズへの移行タイミングと持続時間
  - フェーズ移行の自動／手動判断の適切性評価
  - 移行判断に用いられた指標の有効性分析

- **ユーザー行動パターンの分析**:
  - 各フェーズでのユーザー離脱率変化
  - 代替 UI/機能への遷移率と利用状況
  - 障害時に特に使用頻度が高かった機能の特定

- **復旧効果の測定**:
  - フェーズ移行による業務・収益影響の軽減効果
  - 各フォールバック戦略の有効性評価
  - コスト対効果分析（代替サービス維持コスト vs 障害軽減効果）

<Mermaid chart={`
graph TD
    subgraph "障害影響分析サイクル"
    A[障害検出] --> B[フェーズ移行判断]
    B --> C[障害対応実施]
    C --> D[復旧効果測定]
    D --> E[戦略の改善]
    E --> A
    end

    subgraph "データ収集ポイント"
    F[システムメトリクス] --> A
    G[ユーザー行動ログ] --> D
    H[ビジネスインパクト] --> D
    I[フィードバックデータ] --> E
    end

    classDef analysis fill:#0e7490,stroke:#0e7490,color:white,stroke-width:2px;
    classDef data fill:#6b21a8,stroke:#581c87,color:white,stroke-width:2px;

    class A,B,C,D,E analysis;
    class F,G,H,I data;
`} />

このようなデータ駆動型のアプローチにより、障害対応プロセスを継続的に改善し、フォールバック戦略の有効性を高めることができます。

### 導入事例

#### EC サイトの商品レコメンデーション

- **通常時**: AI を使用したパーソナライズされた商品推奨
- **劣化時**: 人気商品や「よく一緒に購入される商品」などの統計ベースの推奨に切替
- **詳細実装例**:
  ```java
  public List<Product> getRecommendations(User user, Product currentProduct) {
      try {
          // 主要パス: AI レコメンデーションを取得（タイムアウト設定）
          return aiRecommendationService.getPersonalizedRecommendations(
              user, currentProduct, TIMEOUT_MS);
      } catch (AIServiceException | TimeoutException e) {
          // フォールバック 1: このユーザーの過去の購入履歴に基づく推奨
          try {
              return userHistoryService.getSimilarProductsBasedOnHistory(user, LIMIT);
          } catch (Exception e2) {
              // フォールバック 2: この商品と一緒によく購入される商品（キャッシュから）
              try {
                  return frequentlyBoughtTogetherCache.get(currentProduct.getId());
              } catch (Exception e3) {
                  // 最終フォールバック: カテゴリ内の人気商品
                  return popularProductsCache.getByCategory(
                      currentProduct.getCategory(), LIMIT);
              }
          }
      }
  }
  ```

#### 自然言語クエリ検索システム

- **通常時**: AI による自然言語理解と高度な検索結果の提供
- **劣化時**: キーワードベースの検索エンジンにフォールバック
- **システム規模別対応**:
  - **小規模システム**: 単純なキーワード抽出によるフォールバック
  - **中規模システム**: Elasticsearch などを使った代替検索パス
  - **大規模システム**: 複数の地理的に分散した AI サービスインスタンスと自動フェイルオーバー

### まとめ

AI サービスの障害耐性設計において、グレースフルデグラデーションは重要な設計原則です。
適切に実装することで、AI コンポーネントの障害時でもシステム全体の可用性を維持し、ユーザー体験への影響を最小限に抑えることができます。
そのためには、以下の点を意識することが重要です。

- 起こりうる AI 障害パターンを事前に特定し、対策を講じる
- フェーズ別の対応戦略を明確に定義し、移行条件を設定する
- フォールバックメカニズムを必ず用意し、その限界も理解する
- サービスを重要度に応じて階層化する
- ユーザーへの透明性を確保し、UI/UX の一貫性を維持する
- 代替 UI/機能への遷移率など、定量的・定性的な指標を記録し分析する
- 障害発生時のユーザー体験を定期的にテストし、継続的に改善する

### 用語解説

| 用語 | 説明 |
|------|------|
| グレースフルデグラデーション | システムの一部が故障した際に、段階的に機能を低下させながらもコアとなる機能を維持する手法 |
| フォールバックメカニズム | 主要なシステムが失敗した場合に代替手段に切り替える仕組み |
| サーキットブレーカー | 障害の連鎖を防ぐために、障害を検出すると自動的にサービス呼び出しを遮断するパターン |
| プログレッシブエンハンスメント | 基本機能から始め、ブラウザやデバイスの能力に応じて機能を追加していく設計手法 |
| ポストモーテム | システム障害後に行われる詳細な分析と文書化プロセス |
| NPS (Net Promoter Score) | 顧客ロイヤルティを測定する指標で、「この製品・サービスを友人に薦める可能性はどのくらいありますか？」という質問に基づく |
| CSAT (Customer Satisfaction Score) | 顧客満足度を測定する指標で、通常は5段階や10段階のスケールで評価される |
| デグラデーションフェーズ | システム障害の程度に応じて段階的に適用される対応戦略の区分 |
| 代替 UI モード | AI 機能が低下または停止した際に提供される、簡略化されたユーザーインターフェース |
